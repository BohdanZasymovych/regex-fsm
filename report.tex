\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{float}      % provides the [H] placement option
\usepackage{placeins}   % provides \FloatBarrier

\title{Regular Expression Finite State Machine}
\date{\today}

\begin{document}

\maketitle

\section{Introduction}
This project implements a Finite State Machine (FSM) for processing regular expressions. The implementation creates a non‑deterministic finite automaton (NFA) from a given regular expression pattern and provides functionality to check whether input strings match the pattern.

\section{Supported regex patterns}
The implementation supports the following regular expression features:
\begin{itemize}
    \item Basic character matching (e.g., ``abc'' matches exactly ``abc'')
    \item Wildcard character ``.'' (matches any single character)
    \item Repetition operators:
    \begin{itemize}
        \item ``*'' (zero or more occurrences)
        \item ``+'' (one or more occurrences)
    \end{itemize}
    \item Character classes with the following capabilities:
    \begin{itemize}
        \item Basic character sets: \verb|[abc]| (matches any of a, b, or c)
        \item Character ranges: \verb|[a-z]| (matches any lowercase letter)
        \item Negated character classes: \verb|[^abc]| (matches any character except a, b, or c)
    \end{itemize}
\end{itemize}

\section{States of FSM}
The FSM consists of the following state types:
\begin{itemize}
    \item \textbf{StartState}: The initial state of the automaton
    \item \textbf{AsciiState}: Accepts a specific ASCII character
    \item \textbf{DotState}: Accepts any ASCII character (implements the ``.'' wildcard)
    \item \textbf{CharClassState}: Accepts characters based on inclusion or exclusion from a set
\end{itemize}

Each state maintains:
\begin{itemize}
    \item A unique identifier
    \item A set of normal transitions to other states
    \item A set of $\epsilon$‑transitions (transitions without consuming input)
    \item A flag indicating whether it is an accepting state
\end{itemize}

\section{Algorithm of machine creation}
Firstly an empty machine with only the StartState is initialized. Then the regex pattern is processed character by character:
\begin{itemize}
    \item If the char is “.”, a DotState is created.
    \item If the char is “[”, the character‑class parser is invoked. It returns a set of characters, a Boolean for negation, and an updated index. Then a CharClassState is created.
    \item If the char is any other ASCII character, an AsciiState with that char is created.
    \item After creating the state, if the next pattern char is “*” or “+”, a loop transition is added:
      \begin{itemize}
        \item For “*”, an $\epsilon$‑transition back to the current state is added.
        \item For “+”, a normal transition consuming the state’s symbol is added.
      \end{itemize}
    \item If at end‑of‑pattern, the current state is marked accepting.
    \item The current state becomes the “previous” for the next iteration.
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{create_machine.png}
  \caption{Code of function initializing machine}
  \label{fig:create_machine}
\end{figure}
\FloatBarrier

\section{Algorithm of string checking}
During matching, the machine tracks a set of current states—initially the $\epsilon$‑closure of the start state. For each input character:
\begin{itemize}
  \item From each current state, follow transitions labeled with the input char.
  \item Collect all reachable states.
  \item Compute the $\epsilon$‑closure of that set.
  \item That becomes the new current‑states set.
\end{itemize}
After the entire string is consumed, if any current state is accepting, the match succeeds. Then the machine resets its current‑states to the $\epsilon$‑closure of the start state for the next query.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=0.9\textwidth]{check_string_code.png}
  \caption{Functions for checking string match with regex}
  \label{fig:check_string}
\end{figure}
\FloatBarrier

\section{Visualization}
\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\textwidth]{regex_fsm_visualization.png}
  \caption{FSM for regular expression “[a–c]*4.+hi”}
  \label{fig:visualization}
\end{figure}
\FloatBarrier

\section{Project Structure}
The project is organized into several key files:
\begin{itemize}
    \item \textbf{regex.py}: Module with implemented \texttt{RegexFSM} to check match of strings with regex pattern.
    \item \textbf{visualization.py}: Module to create visualization of compiled machine (generated by AI).
    \item \textbf{test\_regex.py}: Module with unit tests (generated by AI).
\end{itemize}

\end{document}
